//! Isotope Grid - RGB Vector Model for Spectroscopic Trace Analysis
//!
//! Each trace contribution carries a "color signature" (RGB vector).
//! This allows analyzing which service types are causing congestion
//! while preserving Source Amnesia (no individual ID tracking).
//!
//! # Key Insight
//! - Bitmask: "A and B are here" (loses proportion)
//! - RGB Vector: "90% A, 10% B are here" (preserves proportion)

use std::sync::atomic::{AtomicU32, Ordering};

/// A single trace pixel with RGB color components.
///
/// Each component represents a service type's contribution.
/// The color is determined by hashing the service name.
///
/// # Memory
/// 12 bytes per cell (3 × 4 bytes) - same as bitmask approach.
pub struct TracePixel {
    /// Red component (accumulated)
    r: AtomicU32,
    /// Green component (accumulated)
    g: AtomicU32,
    /// Blue component (accumulated)
    b: AtomicU32,
}

impl TracePixel {
    fn new() -> Self {
        Self {
            r: AtomicU32::new(0),
            g: AtomicU32::new(0),
            b: AtomicU32::new(0),
        }
    }

    /// Add contribution with color signature.
    ///
    /// Color is in fixed-point (1000 = 1.0).
    fn contribute(&self, amount: u32, color: (u32, u32, u32)) {
        let (cr, cg, cb) = color;
        // Scale contribution by color components
        self.r.fetch_add((amount * cr) / 1000, Ordering::Relaxed);
        self.g.fetch_add((amount * cg) / 1000, Ordering::Relaxed);
        self.b.fetch_add((amount * cb) / 1000, Ordering::Relaxed);
    }

    /// Get total density (r + g + b).
    fn density(&self) -> u32 {
        self.r.load(Ordering::Relaxed)
            + self.g.load(Ordering::Relaxed)
            + self.b.load(Ordering::Relaxed)
    }

    /// Get RGB values.
    fn rgb(&self) -> (u32, u32, u32) {
        (
            self.r.load(Ordering::Relaxed),
            self.g.load(Ordering::Relaxed),
            self.b.load(Ordering::Relaxed),
        )
    }

    /// Get normalized color (for visualization).
    /// Returns (r, g, b) where each is 0.0-1.0.
    fn normalized_color(&self) -> (f32, f32, f32) {
        let total = self.density();
        if total == 0 {
            return (0.0, 0.0, 0.0);
        }
        let (r, g, b) = self.rgb();
        (
            r as f32 / total as f32,
            g as f32 / total as f32,
            b as f32 / total as f32,
        )
    }

    /// Apply decay to all channels.
    fn decay(&self, rate: u32) {
        let r = self.r.load(Ordering::Relaxed);
        let g = self.g.load(Ordering::Relaxed);
        let b = self.b.load(Ordering::Relaxed);
        self.r.store(r.saturating_sub(rate), Ordering::Relaxed);
        self.g.store(g.saturating_sub(rate), Ordering::Relaxed);
        self.b.store(b.saturating_sub(rate), Ordering::Relaxed);
    }
}

/// Isotope-aware density grid with RGB trace tracking.
pub struct IsotopeGrid {
    width: usize,
    height: usize,
    cells: Vec<TracePixel>,
    decay_rate: u32,
    solid_threshold: u32,
    liquid_threshold: u32,
}

/// Service color signature.
/// Generated by hashing service name to RGB.
#[derive(Debug, Clone, Copy)]
pub struct ServiceColor {
    pub r: u32, // 0-1000 (fixed point)
    pub g: u32,
    pub b: u32,
}

impl ServiceColor {
    /// Create from service name using deterministic hash.
    pub fn from_name(name: &str) -> Self {
        let hash = simple_hash(name);
        // Convert hash to RGB components (0-1000 each)
        let r = ((hash >> 16) & 0xFF) * 4; // 0-1020
        let g = ((hash >> 8) & 0xFF) * 4;
        let b = (hash & 0xFF) * 4;
        Self {
            r: r.min(1000),
            g: g.min(1000),
            b: b.min(1000),
        }
    }

    /// Create a pure red color (for testing).
    pub fn red() -> Self {
        Self { r: 1000, g: 0, b: 0 }
    }

    /// Create a pure green color (for testing).
    pub fn green() -> Self {
        Self { r: 0, g: 1000, b: 0 }
    }

    /// Create a pure blue color (for testing).
    pub fn blue() -> Self {
        Self { r: 0, g: 0, b: 1000 }
    }

    fn as_tuple(&self) -> (u32, u32, u32) {
        (self.r, self.g, self.b)
    }
}

/// Simple hash function for deterministic color generation.
fn simple_hash(s: &str) -> u32 {
    let mut hash: u32 = 5381;
    for byte in s.bytes() {
        hash = hash.wrapping_mul(33).wrapping_add(byte as u32);
    }
    hash
}

impl IsotopeGrid {
    /// Create a new isotope grid.
    pub fn new(
        width: usize,
        height: usize,
        decay_rate: u32,
        solid_threshold: u32,
        liquid_threshold: u32,
    ) -> Self {
        let cells = (0..width * height)
            .map(|_| TracePixel::new())
            .collect();
        Self {
            width,
            height,
            cells,
            decay_rate,
            solid_threshold,
            liquid_threshold,
        }
    }

    /// Contribute trace with service color signature.
    ///
    /// This is the isotope-aware version of contribution.
    /// Preserves proportion information (unlike bitmask).
    #[inline]
    pub fn contribute(&self, x: usize, y: usize, amount: u32, color: ServiceColor) {
        if let Some(cell) = self.get_cell(x, y) {
            cell.contribute(amount, color.as_tuple());
        }
    }

    /// Get total density at position.
    #[inline]
    pub fn density(&self, x: usize, y: usize) -> u32 {
        self.get_cell(x, y)
            .map(|c| c.density())
            .unwrap_or(0)
    }

    /// Get RGB values at position.
    #[inline]
    pub fn rgb(&self, x: usize, y: usize) -> (u32, u32, u32) {
        self.get_cell(x, y)
            .map(|c| c.rgb())
            .unwrap_or((0, 0, 0))
    }

    /// Get normalized color at position (for visualization).
    #[inline]
    pub fn color(&self, x: usize, y: usize) -> (f32, f32, f32) {
        self.get_cell(x, y)
            .map(|c| c.normalized_color())
            .unwrap_or((0.0, 0.0, 0.0))
    }

    /// Get dominant service type at position.
    ///
    /// Returns which channel (R/G/B) has highest contribution.
    pub fn dominant_channel(&self, x: usize, y: usize) -> Option<char> {
        let (r, g, b) = self.rgb(x, y);
        if r == 0 && g == 0 && b == 0 {
            return None;
        }
        if r >= g && r >= b {
            Some('R')
        } else if g >= r && g >= b {
            Some('G')
        } else {
            Some('B')
        }
    }

    /// Check if position is habitable.
    #[inline]
    pub fn is_habitable(&self, x: usize, y: usize, threshold: u32) -> bool {
        self.density(x, y) < threshold
    }

    /// Apply global decay to all channels.
    pub fn apply_decay(&self) {
        for cell in &self.cells {
            cell.decay(self.decay_rate);
        }
    }

    /// Get dimensions.
    pub fn dimensions(&self) -> (usize, usize) {
        (self.width, self.height)
    }

    #[inline]
    fn get_cell(&self, x: usize, y: usize) -> Option<&TracePixel> {
        if x < self.width && y < self.height {
            Some(&self.cells[y * self.width + x])
        } else {
            None
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_magnitude_preserved() {
        let grid = IsotopeGrid::new(10, 10, 0, 1000, 500);

        // Auth (Red) contributes 99
        grid.contribute(5, 5, 990, ServiceColor::red()); // 99 × 10 for fixed point
        // Payment (Green) contributes 1
        grid.contribute(5, 5, 10, ServiceColor::green()); // 1 × 10

        let (r, g, b) = grid.rgb(5, 5);

        // Red should be ~99x larger than green
        assert!(r > g * 90, "Red should dominate: r={}, g={}", r, g);
        assert_eq!(b, 0, "Blue should be zero");
    }

    #[test]
    fn test_color_mixing() {
        let grid = IsotopeGrid::new(10, 10, 0, 1000, 500);

        // Equal contributions from Red and Green
        grid.contribute(3, 3, 100, ServiceColor::red());
        grid.contribute(3, 3, 100, ServiceColor::green());

        let (nr, ng, _) = grid.color(3, 3);

        // Should be approximately 50/50 (yellow)
        assert!((nr - ng).abs() < 0.1, "Should be balanced: r={}, g={}", nr, ng);
    }

    #[test]
    fn test_deterministic_hashing() {
        let c1 = ServiceColor::from_name("AuthService");
        let c2 = ServiceColor::from_name("AuthService");
        let c3 = ServiceColor::from_name("PaymentService");

        assert_eq!(c1.r, c2.r, "Same name should produce same color");
        assert_eq!(c1.g, c2.g);
        assert_eq!(c1.b, c2.b);

        // Different names should (likely) produce different colors
        assert!(
            c1.r != c3.r || c1.g != c3.g || c1.b != c3.b,
            "Different names should produce different colors"
        );
    }

    #[test]
    fn test_decay_all_channels() {
        let grid = IsotopeGrid::new(10, 10, 10, 1000, 500);

        grid.contribute(0, 0, 100, ServiceColor::red());
        grid.contribute(0, 0, 100, ServiceColor::green());
        grid.contribute(0, 0, 100, ServiceColor::blue());

        let before = grid.density(0, 0);
        grid.apply_decay();
        let after = grid.density(0, 0);

        // Each channel should decay by 10, total = 30
        assert_eq!(before - after, 30, "All channels should decay");
    }

    #[test]
    fn test_dominant_channel() {
        let grid = IsotopeGrid::new(10, 10, 0, 1000, 500);

        grid.contribute(1, 1, 100, ServiceColor::red());
        grid.contribute(1, 1, 50, ServiceColor::green());

        assert_eq!(grid.dominant_channel(1, 1), Some('R'));

        grid.contribute(1, 1, 200, ServiceColor::green());
        assert_eq!(grid.dominant_channel(1, 1), Some('G'));
    }
}
